from typing import Generator
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt
from pydantic import ValidationError
from sqlalchemy.orm import Session
from app import crud, models, schemas
from app.core import security
from app.core.config import settings
from app.db.session import SessionLocal
import os
import logging

logger = logging.getLogger(__name__)

reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)

#Dependencies
def get_db() -> Generator:
    try:
        db = SessionLocal() #Only the code prior to and including the yield statement is executed before sending a response
        yield db            #The yielded value is what is injected into path operations and other dependencies
    finally:
        db.close()          #The code following the yield statement is executed after the response has been delivered

def verify_with_public_key(token: str = Depends(reusable_oauth2)):
    '''
    Enable verification of a token generated by CAPIF for an API Invoker.
    If env variable USE_PUBLIC_KEY_VERIFICATION is set to False, the verification is ommited.
    '''
    if settings.USE_PUBLIC_KEY_VERIFICATION:
        try:
            cert_path = os.getenv("CAPIF_CERT_PATH", "/app/app/core/certificates/capif_cert_server.pem")
            payload = jwt.decode(
                token, security.extract_public_key(cert_path), algorithms=[security.ALGORITHM[1]]
            )
        except (jwt.JWTError):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials - Token from CAPIF",
            )
        return payload
    else:
        return None

def get_current_user(
    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)
) -> models.User:
    '''
    Enable verification of a token generated by CAPIF for an API Invoker.
    If env variable USE_PUBLIC_KEY_VERIFICATION is set to False, NEF verifies the access token acquired from NEF.
    Else NEF vefirication token is ommited and the function returns the default user
    '''
    if not settings.USE_PUBLIC_KEY_VERIFICATION:
        try:
            payload = jwt.decode(
                token, settings.SECRET_KEY, algorithms=[security.ALGORITHM[0]]
            )
            token_data = schemas.TokenPayload(**payload)
        except (jwt.JWTError, ValidationError):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials - Token from NEF",
            )
        user = crud.user.get(db, id=token_data.sub)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        return user
    else:
        default_email = os.getenv("DEFAULT_ADMIN_EMAIL", "admin@my-email.com")
        if os.getenv("DEFAULT_ADMIN_EMAIL") is None:
            allow_fallback = os.getenv("ALLOW_DEFAULT_ADMIN_FALLBACK", "false").lower() in {"1", "true", "yes"}
            if not allow_fallback:
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail="DEFAULT_ADMIN_EMAIL must be set when public key verification is enabled",
                )
            logger.warning("DEFAULT_ADMIN_EMAIL not set; falling back to %s", default_email)
        user = crud.user.get_by_email(db, email=default_email)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Default admin user '{default_email}' not found in database",
            )
        return user


def get_current_active_user(
    current_user: models.User = Depends(get_current_user),
) -> models.User:
    if not crud.user.is_active(current_user):
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


def get_current_active_superuser(
    current_user: models.User = Depends(get_current_user),
) -> models.User:
    if not crud.user.is_superuser(current_user):
        raise HTTPException(
            status_code=400, detail="The user doesn't have enough privileges"
        )
    return current_user
